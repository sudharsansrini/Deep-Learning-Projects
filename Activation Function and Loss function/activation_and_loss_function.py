# -*- coding: utf-8 -*-
"""activation_and_loss_function.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/15n9WtxJzHeo04W3SwckwFnbXoJjBCvqs

**ACTIVATION FUNCTION**
1. ReLu
2. Leaky ReLu
3. Sigmoid
4. Tanh
5. Step Function
"""

import matplotlib.pyplot as plt

def Relu(x):
  y = []
  for i in x:
    y.append(max(0, i))

  plt.plot(x,y, color='red')
  plt.show()



x = [i for i in range(-5, 5, 1)]
Relu(x)

import matplotlib.pyplot as plt

def Leaky_Relu(x):
  y = []
  for i in x:
    y.append(max(0.1*i, i))

  plt.plot(x,y, color='red')
  plt.show()



x = [i for i in range(-5, 5, 1)]
Leaky_Relu(x)

import matplotlib.pyplot as plt
import math

def sigmoid(x):
  y = []
  for i in x:
    a = 1/(1+math.exp(-i))
    y.append(a)

  plt.plot(x,y, color='red')
  plt.show()



x = [i for i in range(-5, 5, 1)]
sigmoid(x)

import matplotlib.pyplot as plt
import math

def tanh(x):
  y = []
  for i in x:
    a = (math.exp(i) - math.exp(-i)) / (math.exp(i) + math.exp(-i))
    y.append(a)

  plt.plot(x,y, color='red')
  plt.show()



x = [i for i in range(-5, 5, 1)]
tanh(x)

import matplotlib.pyplot as plt
import math

def step_fn(x):
  y = []
  for i in x:
    if i <= 0:
      y.append(0)
    elif i > 0:
      y.append(1)
 
    


  plt.scatter(x,y, color='red')
  plt.show()



x = [i for i in range(-5, 5, 1)]
step_fn(x)

"""**Loss or cost function**
1. sparse_categorical_crossentropy
2. binary crossentropy
3. categorical crossentropy
4. mean absolute error
5. mean squared error
"""

import numpy as np

y_pred = np.array([1,1,0,0,1])
y_true = np.array([0,1,0,1,1])

# Mean Absolute Error
print(np.mean(np.abs(y_pred - y_true)))

import numpy as np

y_pred = np.array([1,1,0,0,1])
y_true = np.array([0,1,0,1,1])

# Mean Squared Error
print(np.mean(np.square(y_pred - y_true)))

import numpy as np

y_pred = np.array([1,1,0,0,1])
y_true = np.array([0,1,0,1,1])

epsilon = 1e-15
y_pred_new = [max(i, epsilon) for i in y_pred]
y_pred_new = [min(i, 1-epsilon) for i in y_pred]

y_pred_final = np.array(y_pred_new)


print(-np.mean(y_true * np.log(y_pred_final) + (1-y_true)* np.log(1-y_pred_final)))